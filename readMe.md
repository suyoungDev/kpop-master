# 프로젝트 소개

K-pop의 전주만 듣고 노래제목을 맞추는 미니 게임 웹 어플리케이션

## 배포

[플레이 하러 가기](https://kpopmaster.herokuapp.com/)

# ✨ 기획

## 사용 스택

![mern](https://user-images.githubusercontent.com/71932072/108599968-9337c280-73d7-11eb-8422-7de91c3e67fc.png)

React의 상태관리는 React Hooks과 Redux를 사용하였습니다.

### 프론트엔드

- 리액트로 구축
- 반응형 웹페이지
- axios를 사용하여 클라이언트-서버 간 RESTful API 형식으로 통신

### 백엔드

- node.js + express를 이용하여 구축
- MongoDB, mongoose를 이용하여 DB 생성
- 유저 정보, 게임 결과, 댓글, 좋아요와 싫어요의 CRUD 가 주요 기능
- YOUTUBE Data API v3를 호출하여 노래제목만으로 영상 정보 검색

## 주요 기능

- 사용자가 플레이할 **난이도**(쉬움, 보통, 어려움), **테마**(가수, 년도별, 이번주) 선택과 적용
- `melon-chart-parser` 디펜던시를 사용하여 음악 정보 가져오기
- `youtube v3 api`를 활용하여 위에서 가져온 음악 정보를 토대로 검색 후 플레이
- 힌트 제공
  - 노래제목이 한글이면, 힌트는 **초성**으로 보여짐
  - 노래제목이 영어면, 힌트는 **무작위**로 뽑힌 3글자 혹은 1글자만 보여짐
- `사용자가 입력한 답안`과 `플레이 중인 노래 제목`를 비교하여 **정답 판별**
- 20초 초과 시 다음 라운드로 넘어감
- 특정 키워드(`!q` 또는 `!ㅂ`) 입력 시, 다음 라운드로 넘어감
- 게임 결과, 유저 정보, 코멘트 정보를 `mongoDB`에 기록
  - 비회원, 미접속 경우 게임 결과는 기록되지 않음
- `mongoDB`에 저장된 기록을 토대로 현재 플레이 점수가 몇등인지 판별
- 회원가입 및 로그인 기능
- `bcrypt`로 유저 정보 암호화, `jwt`로 생성한 `token`은 `cookie`에 보관
- 댓글 기능
- 좋아요와 싫어요
- 명예의 전당: 점수 순으로 랭킹
  - 로그인 유저일 경우, 본인의 전적만 따로 확인 가능
- 획득한 점수에 대응하는 게임 결과 판독
- YOUTUBE API v3의 일일 사용량 제한때문에, API에서 가져오는 데이터 일부를 DB에 저장하여 사용량을 줄임

## 구현 화면

![mobile](https://user-images.githubusercontent.com/71932072/109439779-178ee300-7a73-11eb-9c6a-9b0cc91693a8.png)
![laptop](https://user-images.githubusercontent.com/71932072/109439780-18c01000-7a73-11eb-8172-bb3a6a076030.png)

![howtoplay](https://user-images.githubusercontent.com/71932072/109440066-36da4000-7a74-11eb-9995-67136ca8b55b.png)

# 🔥 문제 해결 경험

## 상태가 뒤늦게 useContext로 전달되는 문제

- **문제**

  - 유저가 선택한 옵션들을 useState에 저장하고, 그 state를 그대로 useContext에 넣어 다음 페이지에서 저장된 옵션들에 맞게 페이지를 구현하였는데, 다음 페이지에서 에러가 남.

- **원인**

  - `useContext`에 전달된 state(옵션값)는 세개 중 첫 두개 뿐이었고, 마지막 옵션이 전달되지 않은 채로 다음 페이지로 넘와서 `undefined`에러가 난 것.

- **측정**

  - 이 문제를 해결하지 못하면, 프로젝트의 핵심 기능인 '전주만 듣고 노래제목 맞추기'가 불가능한 상황이었음.

- **해결과정**

  1. 옵션을 선택할 때마다 콘솔에서 제대로 옵션값이 전달된 것인지 파악을 시도.
  2. 한발 늦게 useState에 값이 전달되어 콘솔에선 undefined으로 떠서 파악이 힘듦
  3. 혹시 그것 때문일까 싶어, 마지막 값은 state가 아닌 변수선언 및 할당 후, 변수값을 useContext에 넣음
  4. 문제가 해결됨.
  5. 파악한 문제를 토대로 리액트 공식 문서를 읽으니, 객체대신 함수로 전달하면 최신 state값을 보장할 수 있다고 함
  6. 함수형으로 코드를 수정함
  7. 해결이 안됨. 다시 변수로 수정함

- **평가**
  - setState의 호출은 비동기적으로 이루어진다는 것에 대해 알게 된 계기가 됨. 그러나 왜 함수형으로 수정했어도 안됐는지 이해가 안되서 아쉬움.

## 리팩토링 할 때 가장 중요한 건 변수명을 수정 하지 않는 것!

- **문제**
  - 리팩토링 후, `년도별`로 옵션 선택 시, 데이터를 못받아와서 게임이 진행이 안됨. `명예의 전당`페이지에서도 새로운 데이터를 받아올 수 없음.
- **원인**
  - 리팩토링 할 때, 더 나은 변수명이라고 생각하여 변수명을 변경했으나 모든 파일에 걸쳐 수정된 변수명을 수정하지 못함.
- **해결 과정**

  1. 어떤 상황에서 에러가 발생한 것인지 유저에게 물어보고, 그 상황을 유도하여 원인을 파악함.
  2. 원인을 파악해 보니 리팩토링한 파일에서만 변수명을 수정하였슴.
  3. mongoDB에 올라간 모든 데이터가 수정 전의 변수명을 쓰고 있었으며, 또한 mongoDB에 쓰이는 스키마도 여전히 수정 전의 변수명을 쓰고 있었슴.
  4. 그래서 새로 데이터를 기록할때마다, 그 수정된 변수명의 데이터는 기록이 되지 않았던 거였슴.
  5. mongoDB에 저장된 데이터를 수정 하는 것 보다는 원래의 변수명으로 쓰는 것이 더 간단할 것이라고 판단.
  6. 원래의 변수명으로 수정하여 에러를 해결함.

- **평가**
  - 이번 케이스를 토대로 한번 작성한 변수명은 최대한 변경하지 않는게 좋다는 걸 깨달았음.
  - 변수명을 변경할 수 밖에 없다면, 최대한 테스트 케이스를 많이 만들어 테스트를 여러 방면으로 돌리는 것이 좋다는 것도 깨달았습니다.

## 좋아요 싫어요 기능

- **문제**

  - `mongoDB`에 좋아요와 싫어요의 데이터를 저장하는 코드를 작성하고 구현이 잘 된 것을 확인했지만, 실제 테스트에서 계속 이상한 에러가 발생함. 좋아요 싫어요 숫자가 마구 날뛰는 것.

- **원인**

  - http통신을 동시에 했기 때문.
  - `좋아요`나 `싫어요`를 누를 때마다, 해당 유저 정보와 해당 코멘트 정보를 DB에 업로드하고, 동시에 DB에서 새로운 정보를 받아왔는데 이런 과정에서 더 빨리 받아온 정보로 순차적으로 화면에 렌더링하느라 숫자가 왔다갔다 했던 것.

- **문제 해결**

  1. `useEffect`로 화면 첫로드에만 `좋아요`와 `싫어요`의 정보를 가져옴.
  2. `좋아요`와 `싫어요` 버튼을 누를 때에만 업로드만 하고, 정보를 가져오진 않게 수정함.
  3. `좋아요`와 `싫어요` 버튼을 누를 때 나타나는 +1, -1 같은 값의 변화는 `useState`로 업데이트 함.

- **평가**
  - 데이터를 가져오는데에는 시간이 걸린다는 것을 인지하지 못해서 벌어진 문제였음.
  - 비록 그게 논리적으로 맞는 기능이라고 할지라도, 로딩에 시간이 걸린다면 동시에 DB에 업로드하고, DB를 받아오는 것은 지양해야한다는 것을 깨달음.
  - 만약 한다고해도 그게 동시에 가능한 web socket이나 실시간으로 주고받을수 있는 firebase의 realtime database를 이용해야 함을 알게 되었음.

## Authentication 기능

- **문제**

  - 접속 회원인지 아닌지 쿠키에 저장된 token을 유저DB와 비교하여, `회원가입/로그인` 또는 `로그아웃`버튼이 보이게 하고 싶었으나, 미가입 유저일 경우 token이 없기때문에 계속 에러로 값이 리턴되어 화면이 렌더링되지않는 에러가 발생함.

- **원인**

  - 미접속 회원일 때, 에러를 리턴하기 때문

- **문제 해결**

  1. 해당하는 token을 가진 유저가 DB에 없을 경우, error를 리턴하는 것이 아니라 `isAuth: false`만 리턴하는 것으로 수정
  2. 해결안됨
  3. 로그인한 유저를 로그인페이지에 접근 불가능하게 하기 위한 HOC때문에, 매번 새로운 페이지가 랜더링 될 때마다 auth 판별을 하여 유저정보를 가져옴.
  4. 리덕스로 유저의 로그인 유무를 판별하는 것을 포기하고 똑같은 전역상태관리인 `useContext`로 유저유무를 판별하는 것을 시도.
  5. 리덕스와 다르게 `AuthContext`에는 기본값으로 `undefined`으로 설정했음.
  6. `AuthContext`는 단순히 로그인과 로그아웃 할 때만 auth판별을 하여 `boolean`으로 전달.
  7. `undefined`일 경우만 `회원가입/로그인` 메뉴가 보이게 수정함.
  8. 문제 해결

- **평가**
  - 뭔가 더 좋은 방법이 있을 것이라고 생각은 되지만, 떠오르는 방법이 없어서 아쉬움이 남음.

## custom hook으로 input을 사용할 때 에러

- **문제**

  - `custom hook`으로 `useInput`을 만들어서 사용함. 그런데 다른 페이지에선 오류가 없었으나 `gameLayout`페이지에서 에러가 발생함

- **원인**

  - input의 `onChange`에 할당한 `onChange` hook이 event를 사용한다는 점을 잊고, `onChange('')` 으로 초기화를 시도하여 발생한 버그.

- **해결 과정**

  1. `gameLayout`페이지에서 사용하는 input은 다른 페이지와 다른 점이 무엇인가 파악함.
  2. 다른 페이지는 입력만 하면 끝이지만, 해당 페이지에서는 input을 초기화하는 기능이 존재함.
  3. 생성한 `onChange('')` 훅은 `event.target.value`를 받는데, `onChange('')`으로 초기화를 시도하면 event가 없기 때문에 발생한 버그.
  4. `resetInput()` 훅을 만들어서 대체하여 해결함.

- **평가**
  - 앞으로 event를 사용하는 hook을 만들 때, reset을 할 가능성이 있는 hook이라면 reset기능을 추가적으로 만들어야 함을 알게됨.

## 모바일의 키보드에 화면이 가려지는 문제

- **문제**

  1. youtube화면은 안보여도 갤럭시에서는 영상으로 인식해서 화면 확대 아이콘이 뜨기때문에, 사용자가 마음만 먹으면 정답을 확인 할 수 있음.
  2. 모바일의 키보드에서 화면이 반 정도 가려지기 때문에, 플레이 도중에 주어지는 힌트가 가려지는 문제

- **원인**

  - 1번: 모바일 디바이스 자체의 브라우저에서 지원하는 기능이며, 동시에 유튜브를 이용하는 프로젝트였기 때문에 벌어지는 문제.
  - 2번: `firefox`나 다른 웹 브라우저에서 제공하는 `responsive design mode`에서는 화상 키보드를 구현하지 않기 때문에, 개발 기간 동안 그사실을 감안하여 공간을 넉넉하게 할당해도 정확히 판단하기 힘듦

- **해결 과정**

  - 1번은 웹개발자가 해결가능한 부분이 아니므로 포기함.
  - 2번은 배포 후, 디자인을 수정하고 다시 배포 후, 수정하여 해결하였음.

- **평가**
  1. 가상머신을 이용하여 키보드가 가려지는 영역을 파악하는 방법이 있지 않을까 뒤늦게 후회함.
  2. 디바이스 자체에서 최대 몇퍼센트까지만 가려진다는 규칙이 있지 않을까 싶음. 다음에 이런 케이스가 있다면 규칙유무를 찾아볼 것 같음.

# 🌼 후기

## ui 부분

토이 프로젝트라고 해도, 아무리 아주 작은 부분이더라도 기획단계에서 완벽하게 만들어야한다는 걸 깨달았습니다. 예를 들면

- round radius value
- color
- margin, pading value(아주 정확하게!)
- width, height value
- 컴포넌트끼리 묶는 컨테이너의 존재까지!
- 컴포넌트의 파일 명!

제가 만든 재사용 컴포넌트는 너무 스파게티 같아 보입니다. 뭔가 추가할 때마다 매번 자그마한 화면의 에러가 나타나서 계속 전체적으로 한번 더 훑어봐야했단게 아쉽습니다. 🤯

애초에 기획단계에서도 파일구조도 파일명도 기획하는 걸까요? 충분히 변별력을 유의하며 파일명을 작성했어도, 나중에 보면 비슷한 파일명이 너무 많아 구분하기 힘들었습니다.😨 파일구조도 너무 복잡해 보이고요. 더 간단하게 보이는 방법은 없는걸까요?

다음에는 Styled Components에서 제공하는 theme provider를 이용해봐야겠습니다. 매번 theme파일을 import 하는 게 번거롭기도 하고, 좀더 코드양을 줄이고 싶어거든요.
